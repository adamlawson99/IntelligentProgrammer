---
layout: post
title:  "Parens"
date:   2020-05-17 09:40:00 -0400
categories: recursion
---
## Generating all pairs of valid parentheses
Recursive functions all very powerful, but can also be non-intuitive and confusing for some. Today, we will be looking at the _parens_ problem found at page 136 in the book **Cracking the Coding Interview**. Tackling this problem will allow us to dive into recursion and also backtracking. By the end of this post I hope you have a better understanding of recursion and of backtracking, both of which are powerful tools for all sorts of problems.

### BackTracking
Backtracking is often brought up when it comes to discussion dynamic programming and recursion, let's look at what it is, how to use it, and when to use it.  Backtracking is defined as "a systematic way to iterate through all the possible configurations of a search space."[^1] This definition is nice and all, but what does it mean to 'iterate through all possible configurations of a search space'? A configuration is an option, a decision we make to persue a certain path in our search space. Our search space is all the options that are available to us after we make a certain decision. Let's imagine we are eploring a maze and we want to find the path that leads to certain point in our maze. Each time we come across an intersection in our maze we have to make decision to continue down one of the paths. Each time we continue down that path to the next intersection we change the configuration we are in and are presented a new set of options. Do I want to go left at this intersection or right? What about the next intersection? We continue making these decision until we **A.** Reach our goal or **B.** Reach a dead-end. Imagine yourself in the maze and this time let's say we lay down a path of breadcumbs that allows us to find our back to the previous intersection. If we reach a dead-end what do we do? We follow our breadcrumbs back to the intersection and explore the next unexplored path. We continue this until we've explored all the possible paths from this intersection. Then what? We _backtrack_ to the last intersection which still has unpexplored paths and explore those, rinse and repeat until we reach our goal.

![Maze 1](https://github.com/adamlawson99/IntelligentProgrammer/raw/master/assets/Images/Parens/maze1.png)
![Maze 2](https://github.com/adamlawson99/IntelligentProgrammer/raw/master/assets/Images/Parens/maze2.png)
![Maze 3](https://github.com/adamlawson99/IntelligentProgrammer/raw/master/assets/Images/Parens/maze3.png)

The maze example ill